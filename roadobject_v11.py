# -*- coding: utf-8 -*-
"""roadObject-v1.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1Bl5RhtCDklgDWuQqxmVgolL-vzl04gpE
"""

# Install dependencies
!pip install torch torchvision ultralytics opencv-python matplotlib numpy tqdm flask pyngrok

# Import libraries
import torch
import torchvision
import cv2
import numpy as np
import matplotlib.pyplot as plt
import glob
import os
import time
import random
from tqdm import tqdm
from ultralytics import YOLO
from torchvision.models.detection import fasterrcnn_resnet50_fpn
from torchvision.ops import box_iou
from torchvision import transforms
from flask import Flask, request, render_template_string, send_from_directory, url_for
from pyngrok import ngrok
from transformers import SegformerFeatureExtractor, SegformerForSemanticSegmentation

# Initialize device
device = torch.device("cuda" if torch.cuda.is_available() else "cpu")
print(f"Using device: {device}")

# ---------------------------
# Data Preparation
# ---------------------------

# Original Dataset (BDD100K)
!gdown --id 1i8D3bvLy8_vIbbn3gQXLbYYzNi3Kw7ED -O /content/archive.zip
!unzip -q '/content/archive.zip' -d '/content/bdd100k'

# New Test Dataset (Replace with your dataset ID)
!gdown --id 1460hpGSD2yVazBvdKvfsN41krYZEG3yT -O /content/new_test.zip
!unzip -q '/content/new_test.zip' -d '/content/new_test'

# ---------------------------
# Model Initialization
# ---------------------------

# Download YOLOv3 weights
!wget https://github.com/ultralytics/yolov3/releases/download/v9.6/yolov3.pt

# Initialize models
yolo_model = YOLO("yolov3.pt")
# Load Faster R-CNN for Object Detection
faster_rcnn_model = fasterrcnn_resnet50_fpn(pretrained=True)
faster_rcnn_model.eval()

# Load DeepLabV3+ for Road Segmentation
deeplab_model = torchvision.models.segmentation.deeplabv3_resnet101(pretrained=True)
deeplab_model.eval()

# Load SegFormer (Transformer-Based Model for Future Work)
feature_extractor = SegformerFeatureExtractor.from_pretrained("nvidia/segformer-b0-finetuned-ade-512-512")
segformer_model = SegformerForSemanticSegmentation.from_pretrained("nvidia/segformer-b0-finetuned-ade-512-512")

# ---------------------------
# Updated process_data Function
# ---------------------------

def process_data(dataset_path, output_folder, is_flask=False):
    os.makedirs(output_folder, exist_ok=True)

    # Check if input is a single image or a directory
    if os.path.isfile(dataset_path):
        processing_list = [dataset_path]  # Single image (Flask case)
    else:
        # Directory (non-Flask dataset processing)
        image_paths = glob.glob(os.path.join(dataset_path, "*.jpg"))
        sampled_images = random.sample(image_paths, min(10, len(image_paths)))
        processing_list = sampled_images  # Use sampled images for datasets

    metrics_list = []

    # Use tqdm only in non-Flask mode
    iterator = tqdm(processing_list, desc="Processing") if not is_flask else processing_list

    for img_path in iterator:
        # Load image
        image = cv2.imread(img_path)
        image_rgb = cv2.cvtColor(image, cv2.COLOR_BGR2RGB)

        # ----------- YOLO Processing ----------- #
        yolo_start = time.time()
        yolo_results = yolo_model(img_path, conf=0.5, iou=0.5, max_det=50)
        yolo_time = (time.time() - yolo_start) * 1000  # ms

        # Save YOLO image
        yolo_img = yolo_results[0].plot()
        yolo_filename = os.path.basename(img_path)
        cv2.imwrite(os.path.join(output_folder, yolo_filename), cv2.cvtColor(yolo_img, cv2.COLOR_RGB2BGR))

        # ----------- DeepLabV3+ Segmentation ----------- #
        seg_start = time.time()
        preprocess = transforms.Compose([
            transforms.ToTensor(),
            transforms.Normalize(mean=[0.485, 0.456, 0.406], std=[0.229, 0.224, 0.225])
        ])
        input_tensor = preprocess(image_rgb).unsqueeze(0).to(device)
        with torch.no_grad():
            output = deeplab_model(input_tensor)["out"][0]
        segmentation = output.argmax(0).byte().cpu().numpy()
        seg_time = (time.time() - seg_start) * 1000  # ms

        # Save segmentation image
        colormap = np.zeros((segmentation.shape[0], segmentation.shape[1], 3), dtype=np.uint8)
        colormap[segmentation == 15] = [255, 0, 0]  # Red for Person
        colormap[segmentation == 7] = [0, 255, 0]   # Green for Car
        seg_filename = f"seg_{os.path.basename(img_path)}"
        cv2.imwrite(os.path.join(output_folder, seg_filename), cv2.cvtColor(colormap, cv2.COLOR_RGB2BGR))

        # ----------- IoU Calculation ----------- #
        pred_boxes = torch.tensor([box.xyxy[0].tolist() for box in yolo_results[0].boxes]) if yolo_results[0].boxes else torch.empty(0)
        frcnn_tensor = torchvision.transforms.ToTensor()(image).unsqueeze(0)
        with torch.no_grad():
            frcnn_results = faster_rcnn_model(frcnn_tensor)
        gt_boxes = frcnn_results[0]['boxes'] if len(frcnn_results[0]['boxes']) > 0 else torch.empty(0)
        iou = box_iou(pred_boxes, gt_boxes).mean().item() if pred_boxes.numel() > 0 and gt_boxes.numel() > 0 else 0.0

        # Collect metrics
        metrics = {
            "yolo_time": yolo_time,
            "seg_time": seg_time,
            "iou": iou
        }
        metrics_list.append(metrics)

        # Only show plots for dataset processing (not in Flask)
        if not is_flask:
            fig, axes = plt.subplots(1, 3, figsize=(15, 5))
            axes[0].imshow(image_rgb)
            axes[0].set_title("Original Image")
            axes[1].imshow(cv2.cvtColor(yolo_img, cv2.COLOR_BGR2RGB))
            axes[1].set_title("YOLOv8 Detection")
            axes[2].imshow(colormap)
            axes[2].set_title("DeepLabV3+ Segmentation")
            plt.show()

    return metrics_list  # Return metrics for all processed images

# Process both datasets
print("Initial Training Model")
process_data("/content/bdd100k/bdd100k/bdd100k/images/10k/val/", "/content/original_results")
print("-----------------------------")

print("New Dataset Test Model")
process_data("/content/new_test/trafic_data/train/images", "/content/new_test_results")
print("---------------------------------")

# ---------------------------
# Flask + ngrok Deployment Code
# ---------------------------

# Install pyngrok (if needed)
!pip install -q pyngrok

from flask import Flask, request, render_template_string, send_from_directory, url_for
from pyngrok import ngrok, conf
import os

# ========== NGROK SETUP ========== #
ngrok.set_auth_token("2kVPmoifvczgjR0qNwhE4lGg1rQ_2iH6UJum5X7f9sAnJ2efk")  # ‚Üê REPLACE HERE
conf.get_default().region = "us"  # or "eu"
conf.get_default().bind_tls = True
# ================================= #

app = Flask(__name__)

# Configure paths
UPLOAD_FOLDER = "/content/uploads"
RESULT_FOLDER = "/content/results"
os.makedirs(UPLOAD_FOLDER, exist_ok=True)
os.makedirs(RESULT_FOLDER, exist_ok=True)
app.config['UPLOAD_FOLDER'] = UPLOAD_FOLDER

@app.route("/", methods=["GET", "POST"])
def index():
    if request.method == "POST":
        file = request.files["file"]
        if not file:
            return "No file uploaded!", 400

        # Save uploaded file
        filepath = os.path.join(app.config['UPLOAD_FOLDER'], file.filename)
        file.save(filepath)

        # Process the image (is_flask=True skips plt.show())
        metrics_list = process_data(filepath, RESULT_FOLDER, is_flask=True)
        metrics = metrics_list[0]  # Get metrics for the single image

        # Generate URLs for display
        original_url = url_for('upload_file', filename=file.filename)  # Now works
        yolo_url = url_for('result_file', filename=file.filename)
        seg_url = url_for('result_file', filename=f"seg_{file.filename}")

        return render_template_string('''
            <div style="display:flex;flex-direction:column;align-items:center; justify-content:center">
            <h1>Results</h1>
            <div style="display: flex; gap: 20px;">
                <div><img src="{{ original_url }}" width="300"><br>Original</div>
                <div><img src="{{ yolo_url }}" width="300"><br>YOLO Detection</div>
                <div><img src="{{ seg_url }}" width="300"><br>Segmentation</div>
            </div>
            <h3 style="margin-top:30px;">Metrics</h3>
            <div style="width:250px; text-align:left;margin-top:10px;">
            <p>YOLO Inference: {{ metrics.yolo_time | round(1) }} ms</p>
            <p>Segmentation Inference: {{ metrics.seg_time | round(1) }} ms</p>
            <p>Mean IoU: {{ metrics.iou | round(2) }}</p>
            </div>
            <a href="/">Upload Another</a>
            </div>
        ''', original_url=original_url, yolo_url=yolo_url, seg_url=seg_url, metrics=metrics)

    return render_template_string('''
        <div style="display:flex;flex-direction:column; justify-content:center; align-items:center">
        <h1 style="text-align:center">Upload Image</h1>
        <form method="post" enctype="multipart/form-data" style="text-align:center">
            <input type="file" name="file" accept=".jpg,.jpeg,.png" required>
            <input type="submit" value="Upload">
        </form>
        </div>
    ''')

@app.route("/results/<filename>")
def result_file(filename):
    return send_from_directory(RESULT_FOLDER, filename)

@app.route("/uploads/<filename>")
def upload_file(filename):
    return send_from_directory(app.config['UPLOAD_FOLDER'], filename)


if __name__ == "__main__":
    try:
        # Kill existing processes
        !pkill -f ngrok
        !fuser -k 5000/tcp

        # Start ngrok tunnel
        tunnel = ngrok.connect(5000, proto="http", bind_tls=True)
        print(f"Public URL: {tunnel.public_url}")

        # Run Flask
        app.run(host='0.0.0.0', port=5000)
    except Exception as e:
        print(f"Error: {str(e)}")